#---
# Filename: apache_error_parser.vrl
# Purpose: Parse Apache error logs from syslog format
# Description: Extracts Apache error log fields including timestamp, level, client IP,
#              error messages, and additional metadata like hostname and URI
# Version: 1.0.2
# Changelog: |
#   ## [1.0.2] - 2025-01-01
#   Fixed fallible predicate errors with proper null checks
#   ## [1.0.1] - 2025-01-01
#   Fixed return statement syntax error
#   ## [1.0.0] - 2025-01-01
#   Initial implementation for Apache error log parsing
# Copyright: © 2025 HyperSec Pty Ltd
# Licence: "HyperSec EULA © 2025"
# Env:
#   LOG_LEVEL: Minimum log level to process (default: error)
# Flow: >
#   Extract message -> Parse Apache format -> Extract fields -> Normalize -> Return
#---

# Exit fast if no message to process
if !exists(.msg) {
  .apache = {}
} else {
  # Extract primary message content
  msg = string!(.msg)

  # Check if this is an Apache formatted log with timestamp
  if contains(msg, "[") && contains(msg, "]") {
    # Split by brackets to extract components
    parts = split(msg, "[")
    
    # Extract timestamp if present (format: [Day Mon DD HH:MM:SS YYYY])
    if length(parts) > 1 {
      timestamp_part = string!(parts[1])
      if contains(timestamp_part, "]") {
        timestamp_parts = split(timestamp_part, "]")
        if length(timestamp_parts) > 0 {
          .apache.timestamp = timestamp_parts[0]
        }
      }
    }
    
    # Extract log level if present (format: [error], [warn], etc)
    if length(parts) > 2 {
      level_part = string!(parts[2])
      if contains(level_part, "]") {
        level_parts = split(level_part, "]")
        if length(level_parts) > 0 {
          .apache.level = level_parts[0]
        }
      }
    }
    
    # Extract client IP if present (format: [client X.X.X.X])
    if length(parts) > 3 {
      client_part = string!(parts[3])
      if contains(client_part, "client ") {
        client_parts = split(client_part, "client ")
        if length(client_parts) > 1 {
          client_ip_part = string!(client_parts[1])
          if contains(client_ip_part, "]") {
            ip_parts = split(client_ip_part, "]")
            if length(ip_parts) > 0 {
              .apache.client_ip = ip_parts[0]
            }
          }
        }
      }
    }
    
    # Extract the main error message (everything after the client section)
    if contains(msg, "] ") {
      msg_parts = split(msg, "] ")
      # Find the message part (usually the last substantial part)
      if length(msg_parts) > 3 {
        .apache.message = msg_parts[3]
      } else if length(msg_parts) > 2 {
        .apache.message = msg_parts[2]
      } else if length(msg_parts) > 1 {
        .apache.message = msg_parts[1]
      }
    }
    
    # Extract specific error details from the message
    if exists(.apache.message) {
      apache_msg = string!(.apache.message)
      
      # Extract HTTP status code if present
      if contains(apache_msg, "code ") {
        code_parts = split(apache_msg, "code ")
        if length(code_parts) > 1 {
          code_value = string!(code_parts[1])
          if contains(code_value, ".") {
            code_end_parts = split(code_value, ".")
            if length(code_end_parts) > 0 {
              .apache.status_code = to_int(code_end_parts[0]) ?? null
            }
          } else if contains(code_value, " ") {
            code_end_parts = split(code_value, " ")
            if length(code_end_parts) > 0 {
              .apache.status_code = to_int(code_end_parts[0]) ?? null
            }
          }
        }
      }
      
      # Extract error_code if present
      if contains(apache_msg, "error_code=") {
        error_parts = split(apache_msg, "error_code=")
        if length(error_parts) > 1 {
          error_value = string!(error_parts[1])
          if contains(error_value, " ") {
            error_end_parts = split(error_value, " ")
            if length(error_end_parts) > 0 {
              .apache.error_code = to_int(error_end_parts[0]) ?? null
            }
          }
        }
      }
      
      # Extract hostname if present (format: [hostname "X.X.X.X"])
      if contains(apache_msg, "hostname \"") {
        host_parts = split(apache_msg, "hostname \"")
        if length(host_parts) > 1 {
          host_value = string!(host_parts[1])
          if contains(host_value, "\"") {
            host_end_parts = split(host_value, "\"")
            if length(host_end_parts) > 0 {
              .apache.target_hostname = host_end_parts[0]
            }
          }
        }
      }
      
      # Extract URI if present (format: [uri "/path"])
      if contains(apache_msg, "uri \"") {
        uri_parts = split(apache_msg, "uri \"")
        if length(uri_parts) > 1 {
          uri_value = string!(uri_parts[1])
          if contains(uri_value, "\"") {
            uri_end_parts = split(uri_value, "\"")
            if length(uri_end_parts) > 0 {
              .apache.uri = uri_end_parts[0]
            }
          }
        }
      }
      
      # Extract file path if "File does not exist" error
      if contains(apache_msg, "File does not exist: ") {
        file_parts = split(apache_msg, "File does not exist: ")
        if length(file_parts) > 1 {
          .apache.missing_file = file_parts[1]
        }
      }
      
      # Check for mod_security
      if contains(apache_msg, "mod_security") {
        .apache.mod_security = true
      }
    }
  } else {
    # Simple message without Apache formatting
    .apache.message = msg
  }

  # Normalize fields (at the end as per requirements)
  if exists(.apache.level) {
    .apache.level = downcase(string!(.apache.level))
  }

  if exists(.apache.client_ip) {
    .apache.client_ip = string!(.apache.client_ip)
  }

  # Set field types for schema
  .apache._field_types = {
    "timestamp": "string",
    "level": "string_lowcardinality", 
    "client_ip": "string_fast",
    "message": "text",
    "status_code": "int16",
    "error_code": "int16",
    "target_hostname": "string",
    "uri": "string",
    "missing_file": "string",
    "mod_security": "boolean"
  }
}